#summary MultiIndexContainer for fast indexing of JavaBeans.

= How to use MultiIndexContainer to simplify and faster seeking of data =

== Lets begin with example not using MultiIndexContainer ==

Suppose to have many instances of data class Person you want to lookup 
{{{
public class Person{
    private int id; // Unique id
    private Integer birthYear;
    private String name;
    private String surname;
    private boolean man;
    
    public Person() {           
    }    
    
    public Person(int id, Integer birthYear, String name, String surname, boolean isMan) {
        this.id = id;
        this.birthYear = birthYear;
        this.name = name;
        this.surname = surname;
        this.man = isMan;
    }    
   
    public Integer getBirthYear() {     
        return birthYear;
    }   
               
    public String getName() {
        return name;
    }

    public String getSurname() {
        return surname;
    }
    
    public boolean isMan() {            
        return man;
    }
}
}}}


For brevity and to simplify generating huge data lets use some generator
{{{
import java.util.ArrayList;
import java.util.Collection;

public class PersonGenerator {

        public static Collection<Person> generatePersons(int count) {
                Collection<Person> res = new ArrayList<Person>();
                for(int i =0; i < count; i++) {
                        res.add(new Person(i, 1950+(i%61), "Name"+(i%100), "Surname"+(100-(i%100)), i %2 == 0));
                }
                return res;
        }
}
}}}

== Lets generate 10000 persons and try to find born in 1970 ==
{{{
public static void main(String[] args) {
        Collection<Person> generatedPersons = PersonGenerator
                        .generatePersons(10000);
        Collection<Person> res = new ArrayList<Person>();
        for (Person p : generatedPersons) {
                if (p.getBirthYear() == 1970) {
                        res.add(p);
                }
        }
        System.out.println("Found " + res.size() + " persons born in 1970");
}
}}}

Console output:
_Found 164 persons born in 1970_

*Great!*

== Now include only women born in 1970 ==
{{{
public static void main(String[] args) {
        Collection<Person> generatedPersons = PersonGenerator
                        .generatePersons(10000);
        Collection<Person> res = new ArrayList<Person>();
        for (Person p : generatedPersons) {
                if (p.getBirthYear() == 1970 && !p.isMan() && "Surname81".equals(p.getSurname())) {
                        res.add(p);                             
                }
        }               
        System.out.println("Found " + res.size() + " women born in 1970 with surname 'Surname81'");
}
}}}
Console output:
_Found 2 women born in 1970 with surname 'Surname81'_

*Great!*

= Now take a look how to solve the same tasks using MultiIndexContainer =

== Step 1 implement interface 'cz.kamosh.multiindex.interf.IMultiIndexed' ==
MultiIndexContainer requires JavaBeans implementing this interface to provide unique identifier of each record.

In resulting Person class (shown after Step 2) notice implemented method
{{{
@Override
public Integer getMultiIndexPk() {
        return id;
}
}}}

== Step 2 annotate getters you want to have indexes on ==
Annotation 'cz.kamosh.multiindex.annotation.MultiIndexed' should be used on getters.

So the resulting Person class will be changed to:
{{{
import cz.kamosh.multiindex.annotation.MultiIndexed;
import cz.kamosh.multiindex.interf.IMultiIndexed;

public class Person implements IMultiIndexed<Integer>{
    private int id; // Unique id
    private Integer birthYear;
    private String name;
    private String surname;
    private boolean man;
    
    public Person() {           
    }    
    
    public Person(int id, Integer birthYear, String name, String surname, boolean isMan) {
        this.id = id;
        this.birthYear = birthYear;
        this.name = name;
        this.surname = surname;
        this.man = isMan;
    }    
   
    @MultiIndexed
    public Integer getBirthYear() {     
        return birthYear;
    }   
               
    public String getName() {
        return name;
    }

    @MultiIndexed
    public String getSurname() {
        return surname;
    }
    
    @MultiIndexed
    public boolean isMan() {            
        return man;
    }
    
    @Override
    public Integer getMultiIndexPk() {
        return id;
    }
}  
}}}

== Step 3 (performed automatically on background) - generating index constants ==
[http://code.google.com/p/multiindexcontainer/wiki/IndexConstantGenerator See setting of annotation processor]

Due to annotation processing new class Person_Indexes.java has been automatically generated
{{{
import cz.kamosh.multiindex.interf.Indexable;

/**
 * Do not edit this file. It is generated using generator
 * {@link cz.kamosh.multiindex.annotation.MultiIndexContainerGenerator}
 * based on annotated file {@link Person}
 */
public enum Person_Indexes implements Indexable<Person> {

    Man {
        public Object getIndexedValue(Person record) {
              return record.isMan();
        }
    },
    Surname {
        public Object getIndexedValue(Person record) {
              return record.getSurname();
        }
    },
    BirthYear {
        public Object getIndexedValue(Person record) {
              return record.getBirthYear();
        }
    },
}
}}}

== Lets generate 10000 persons and try to find born in 1970 ==
{{{
import cz.kamosh.multiindex.impl.MultiIndexContainerEnum;
import cz.kamosh.multiindex.interf.IMultiIndexContainerEnum;
...

public static void main(String[] args) {
        Collection<Person> generatedPersons = PersonGenerator
                        .generatePersons(10000);
        IMultiIndexContainerEnum<Person,Integer> mic = new MultiIndexContainerEnum<Person, Integer>(generatedPersons);
        // Add index for birth year
        mic.addIndex(Person_Indexes.BirthYear);
        // Find persons born 1970
        Collection<Person> res =mic.find(mic.eq(Person_Indexes.BirthYear, 1970));               
        System.out.println("Found " + res.size() + " persons born in 1970");
}
}}}
Console output:
_Found 164 persons born in 1970_

Yippee!!! We got to the same result as previously used loop with condition:-)


== Now include only women born in 1970 ==
{{{
import cz.kamosh.multiindex.impl.MultiIndexContainerEnum;
import cz.kamosh.multiindex.interf.IMultiIndexContainerEnum;
...

public static void main(String[] args) {
        Collection<Person> generatedPersons = PersonGenerator
                        .generatePersons(10000);
        IMultiIndexContainerEnum<Person, Integer> mic = new MultiIndexContainerEnum<Person, Integer>(
                        generatedPersons);
        // Add index for birth year
        mic.addIndex(Person_Indexes.BirthYear, Person_Indexes.Man,
                        Person_Indexes.Surname);
        // Find women born in 1970 with surname 'Surname81'
        Collection<Person> res = mic.find(mic.conjunction()
                        .add(mic.eq(Person_Indexes.BirthYear, 1970))
                        .add(mic.eq(Person_Indexes.Man, false))
                        .add(mic.eq(Person_Indexes.Surname, "Surname81")));
        System.out.println("Found " + res.size()
                        + " women born in 1970 with surname 'Surname81'");
}
}}}
Console output:
_Found 2 women born in 1970 with surname 'Surname81'_

Hurray!!! Again the same result as in previous example.


= So, this is MultiIndexContainer:-) ==

== What are other features of MultiIndexContainer ==
=== Finding rules (expressions) ==
Look into cz.kamosh.multiindex.interf.IMultiIndexContainer methods:
  * EQUALS
  * GREATER THAN 
  * LESS THAN 
  * BETWEEN 
  * IS NULL
  * IS NOT NULL
  * IN clause
  * AND operator (conjuction)
  * OR operator (disjunction)

=== Adding and removing records ===
MultiIndexContainer is thread safe

.. to be condinued TODO ...